from utils import *

class MAS():
    def __init__(self, model_list):
        self.llm = LLM(model_list)

    def forward(self, taskInfo):
        """
        A multi-agent system for solving coding tasks.
        
        Steps:
            1. Generate multiple candidate solutions for the given problem.
            2. Use an ensemble mechanism to identify the most consistent solution.
            3. Validate the selected solution using test cases.
            4. If the solution fails, attempt to fix it and return the corrected solution.
        """

        # Call `get_function_signature` to generate the function signature based on the task information
        function_signature = get_function_signature(llm=self.llm, taskInfo=taskInfo)

        # Call `get_test_cases` to generate a list of test cases for the function
        test_cases = get_test_cases(llm=self.llm, taskInfo=taskInfo, function_signature=function_signature)

        solutions = []  # List to store generated solutions.

        # Get the instruction for LLM to generate code based on the task and function signature.
        code_generate_instruction =  f"""Task:
{taskInfo}

Function Signature:
{function_signature}

Generate a Python function to solve the given problem. Ensure the function name \
matches the one specified in the problem. Include necessary imports. Use clear \
variable names and add comments for clarity.

Ensure the function adheres to the provided signature.

Wrap your final code solution in <Code Solution> and </Code Solution>. For example:
<Code Solution>
Your function code here
</Code Solution>
""" # fix the output format for easier extraction

        # Generate three solutions for ensemble evaluation.
        for _ in range(3):  
            # Call `generate_and_extract_code` to generate answer and extract the code.
            answer, code = generate_and_extract_code(llm=self.llm, prompt=code_generate_instruction)
            # Store the answer and the code
            solutions.append(
                {
                    "answer": answer,
                    "code": code
                }
            )

        # Use the ensemble process to select the best solution.
        best_answer, code = self.sc_ensemble(taskInfo=taskInfo, solutions=solutions)
        
        # Test the selected solution by calling `test_code_get_feedback` predefined in utils.
        correct_count, feedback = test_code_get_feedback(code=code, test_cases=test_cases)

        if correct_count == len(test_cases):
            return best_answer  # Return the solution if all tests pass.
        else:
            # Fix the solution if it fails the test cases.
            return self.fix_code(taskInfo=taskInfo, failed_solution=best_answer, feedback=feedback)
    
    def generate_code(self, taskInfo, function_signature):
        """
        Generates Python code for a given task and function signature.

        Args:
            taskInfo (str): A description of the task or problem.
            function_signature (str): The function signature, including the function name, parameters, and return type.
                                    
        Returns:
            tuple: A tuple containing:
                - answer (str): The complete response from the LLM.
                - code (str): The extracted Python code solution generated by the LLM.
        """
        # Get the instruction for LLM to generate code based on the task and function signature.
        code_generate_instruction =  f"""Task:
{taskInfo}

Function Signature:
{function_signature}

Generate a Python function to solve the given problem. Ensure the function name \
matches the one specified in the problem. Include necessary imports. Use clear \
variable names and add comments for clarity.

Ensure the function adheres to the provided signature.

Wrap your final code solution in <Code Solution> and </Code Solution>. For example:
<Code Solution>
Your function code here
</Code Solution>
""" # fix the output format for easier extraction

        # Call `generate_and_extract_code` to generate answer and extract the code.
        answer, code = generate_and_extract_code(llm=self.llm, prompt=code_generate_instruction) 
        return answer, code


    # Function to implement the ensemble voting mechanism for selecting the best solution.
    def sc_ensemble(self, taskInfo, solutions, max_retries=3):
        """
        Self-Consistency Ensemble to select the most reliable solution.

        Args:
            task_info (str): The description of the task.
            solutions (list): The solutions to be evaluated.
            max_retries (int): Maximum number of retries if solution extraction fails. Default is 3.

        Returns:
            tuple: A tuple containing:
                - str: The final chosen solution after Self-Consistency Ensemble.
                - str: The code of the final chosen solution.
        """
        import re

        # Prepare the solutions in a numbered format for evaluation
        solutions_str = ""
        for i, solution in enumerate(solutions):
            answer = solution["answer"]
            solutions_str += f"[[{i+1}]]\n{answer}\n\n"

        # Generate the ensemble voting instruction based on the task information and solutions
        ensemble_instruction = f"""Given the question described as follows: {taskInfo}
        
Several solutions have been generated to address the given question. They are as follows:
{solutions_str}

Carefully evaluate these solutions and identify the answer that appears most frequently across them. This consistency in answers is crucial for determining the most reliable solution.

Provide a detailed explanation of your thought process. Then give your choice of the most reliable answer. Output only the ID (<<1>>, <<2>>]], etc.) corresponding to the most consistent solution. Wrap your final choice with <<>> and without including any additional text or explanation in it.

For example:
<<1>>
""" 

        retries = 0
        while retries < max_retries:
            # Call the LLM to generate an answer, a ralatively low temperature to improve accuracy
            answer = self.llm.call_llm(ensemble_instruction, temperature=0.3)

            # Attempt to extract the selected solution ID from the response
            numbers = re.findall(r'\<\<(\d+)\>\>', answer)
            if numbers:  # If at least one match is found
                try:
                    index = int(numbers[0]) - 1  # Convert to zero-based index
                    if 0 <= index < len(solutions):
                        return solutions[index]["answer"], solutions[index]["code"]  # Return the selected solution
                except ValueError:
                    pass  # In case the match is not a valid number

            # Increment retry counter if extraction fails
            retries += 1

        # If all retries fail, return the first solution as a fallback
        return solutions[0]["answer"], solutions[0]["code"]

    # Function to fix a solution that fails test cases.
    def fix_code(self, taskInfo, failed_solution, feedback):
        """
        Fix the solution if it fails test cases.

        Args:
            taskInfo (str): The description of the problem.
            failed_solution (str): The solution that failed the test cases.
            feeback (str): the description of failed cases.

        Returns:
            str: The fixed solution.
        """
        # Get the instruction for fixing the code based on the task information, failed solution, and feedback.
        fix_code_instruction = f"""The provided solution failed to pass the tests. Please analyze the error and fix the \
code. Ensure the function name and signature remain unchanged. If necessary, add \
or modify imports, correct logical errors, and improve the implementation.

Problem:
{taskInfo}
Failed solution: 
{failed_solution}
Test Feedback:
{feedback}

Provide the corrected function below.
Ensure the function adheres to the origin signature.
"""
        # Call the llm to obtain the fixed solution.
        fixed_solution = self.llm.call_llm(fix_code_instruction)
        return fixed_solution